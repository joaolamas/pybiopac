# !/usr/bin/env python3
# -*- coding: utf-8 -*-
"""pybiopac class.

This module allows to connect with the NDT from Biopac AcqKnowledge software.
from AcqKnowledge-5-Software_guide.pdf:
"Network Data Transfer (NDT) is a real-time data transfer system that allows
access to the data being acquired into a graph by AcqKnowledge for use in an
external application; the AcqKnowledge process and the custom application may
run on the same computer.

Make TCP or UDP connections to external applications and stream binary data
during acquisitions. Network Data Transfer is supported in MP160 or MP150
hardware only.

NDT is a basic method for allowing third party applications to tap into the
data stream being generated by both the MP unit and AcqKnowledge during data
acquisitions. NDT provides
    § networking facilities that allow for integration into a distributed
    application environment
    § basic control facilities to allow external applications to query and
    control the AcqKnowledge application state.
The NDT system is split into two separate types of connections: data
connections and the control connection.
    A. Data connections deliver data from AcqKnowledge to external applications
    during acquisitions.
    B. Control connections are made from external applications to AcqKnowledge
    to query application state and adjust data connections.
The server refers to the AcqKnowledge process and the computer on which it is
running. The client refers to the custom application that is to receive data
from AcqKnowledge and the computer on which it is running. All connections
should be made using standard network protocols, either TCP or UDP. Single
system image architectures should make connections using the loopback
interface. It is assumed that network implementations have appropriate IP
networks in place with routing between machines that can be identified either
by IP address or by hostname. Firewalls must be properly configured to allow
network communications between the client and server. Appropriate network
configuration is the user’s responsibility."

Example:
        $ python
        >>> from biopac import *
        >>> b = pybiopac()

Todo:
    * Test some functions that were not tested

"""
import xmlrpc.client
import requests
import sys
import re


class pybiopac:
    """
    Connection to Biopac NDT (Network Data Transfer) XML-RPC API endpoint.

    This Class receives as input the IP and Port of the AcqKnowledge running
    software where the proxy server is ON.
    More info about the implemented methods:
    https://www.biopac.com/wp-content/uploads/AcqKnowledge-5-Software-Guide.pdf
    page 482 to 495

    Current Methods: (with * not tested)
    getChannelMembers
    getMethodData_ChannelStructure
    getMethodData_ChannelAndBoolStrucure
    getMethodData_ChannelAndIntStrucure
    getMethodData_ChannelAndTypeStrucure
    getMPUnitType
    getEnabledChannels
    getAnalogChannels
    getDigitalChannels
    getCalcChannels
    getChannelScaling
    getSampRate
    getDownsamplingDivider
    getDataConnectionMethod
    changeDataConnectionMethod
    getDataConnectionHostname
    changeDataConnectionHostname
    getTransportType
    changeTransportType
    getUDPSize
    setUDPPacketSize
    getUDPBroadcastEnabled
    changeUDPBroadcastEnabled
    getSingleConnectionModePort
    changeSingleConnectionModePort
    getDataDeliveryEnabled
    changeDataDeliveryEnabled
    getMostRecentSampleValueDeliveryEnabled
    changeMostRecentSampleValueDeliveryEnabled
    getDataConnectionPort
    changeDataConnectionPort
    getDataType
    changeDataType*
    setDataConnectionTimeoutSec
    getMostRecentSampleValue
    getMostRecentSampleValueArray
    loadTemplate*
    getAcquisitionInProgress*
    toggleAcquisition*
    setOutputChannel*

    Attributes:
    ip
    port
    proxyName
    proxyNameEndPoint
    proxyOn
    requestsHeader
    biopacXMLRPC
    unit
    analogChannels
    digitalChannels
    calcChannels
    offset
    scale
    fs
    downSampDivider
    connectionMethods
    DataConnectionHostname
    TcpOrUDP
    UDPSize
    dataConnectionPort
    endianDataType
    cstyleDataType

    In some cases this class will use xmlrpc to do some requests, in another
    cases (when a more complex input structure is needed for a method call)
    it will be used HTTP requests
    Developed by João Lamas: lamas.jp@gmail.com

    """

    structMethod = """<?xml version='1.0'?>
    <methodCall>\n<methodName>acq.{func}</methodName>
    <params>
    {struct}
    </params>
    </methodCall>
    """

    paramStruct = """
    <param>
    <value>
    <struct>{member}</struct>
    </value>
    </param>
    """

    paramSingle = """
    <param>
    <value>
    <{type}>{value}</{type}>
    </value>
    </param>
    """

    paramEmpty = """
    <param>
    <value>
    {value}
    </value>
    </param>
    """

    structMemberType = """
    <member>
    <name>type</name>
    <value><{type}>{value}</{type}></value>
    </member>
    """

    structMemberEndian = """
    <member>
    <name>endian</name>
    <value><string>{value}</string></value>
    </member>
    """

    structMemberIndex = """
    <member>
    <name>index</name>
    <value><{type}>{value}</{type}></value>
    </member>
    """

    def __init__(self, ip="192.168.137.40", port=15010):
        """
        Call Constructor Function.

        Args:
            ip: the ip of the proxy (String)
            port: port of the proxyServer (int)
        Returns:
            True for success, False otherwise
            Object.unit is recognized

        """
        self.ip = ip
        self.port = port
        self.proxyName = "http://"+self.ip+":"+str(self.port)
        self.proxyNameEndPoint = "http://"+self.ip+":"+str(self.port)+'/RPC2'
        self.proxyOn = False
        self.requestsHeader = {'Content-Type': 'text/xml'}
        self.analogChannels = 0
        self.digitalChannels = 0
        self.calcChannels = 0
        try:
            self.biopacXMLRPC = xmlrpc.client.ServerProxy(self.proxyName, verbose=False)
            self.unit = self.biopacXMLRPC.acq.getMPUnitType()
            self.proxyOn = True
            print('Connected')
        except xmlrpc.client.ProtocolError:
            e = sys.exc_info()[1]
            self.proxyOn = False
            print('Xml RPC Protocol error!!')
        except TimeoutError:
            self.proxyOn = False
            print('Connection Problem, certify the ip and port!!!')
        except IOError as e:
            self.proxyOn = False
            print("I/O error({0}): {1}".format(e.errno, e.strerror))

    def getChannelMembers(self, channel='analog', index=0):
        """
        XML Struct with Channel and Index.

        method to build xml structure with input:
        channel - 'analog' 'digital' or 'calc'
        index - number of the channel
        returns:
        member - xml structure
        """
        Channel = self.structMemberType.format(type='string', value=channel)
        Index = self.structMemberIndex.format(type='int', value=index)
        member = Channel + Index
        return member

    def getMethodData_ChannelStructure(self, method, channel, index):
        """
        XML Struct with Channel Structure.

        method to build xml structure with:
        method - the function you want to call
        channel - 'analog' 'digital' or 'calc'
        index - number of the channel
        returns:
        data - xml structure
        """
        member = self.getChannelMembers(channel=channel, index=index)
        param = self.paramStruct.format(member=member)
        data = self.structMethod.format(func=method, struct=param)
        return data

    def getMethodData_ChannelAndBoolStrucure(self, method, channel, index, boolean=True):
        """
        XML Struct with double parameters input: Channel Structure and Bool.

        method to build xml structure with:
        method - the function you want to call
        channel - 'analog' 'digital' or 'calc'
        index - number of the channel
        boolean - True or False
        returns:
        data - xml structure
        """
        member = self.getChannelMembers(channel=channel, index=index)
        param1 = self.paramStruct.format(member=member)
        if boolean is True:
            param2 = self.paramSingle.format(type='boolean', value=1)
        elif boolean is False:
            param2 = self.paramSingle.format(type='boolean', value=0)
        else:
            print('Not valid value!')
            return 0
        data = self.structMethod.format(func=method, struct=param1+param2)
        return data

    def getMethodData_ChannelAndIntStrucure(self, method, channel, index, integer):
        """
        XML Struct with double parameters input: Channel Structure and Integer.

        method to build xml structure with:
        method - the function you want to call
        channel - 'analog' 'digital' or 'calc'
        index - number of the channel
        integer - int
        returns:
        data - xml structure
        """
        member = self.getChannelMembers(channel=channel, index=index)
        param1 = self.paramStruct.format(member=member)
        param2 = self.paramSingle.format(type='integer', value=int(integer))
        data = self.structMethod.format(func=method, struct=param1+param2)
        return data

    def getMethodData_ChannelAndFloatStrucure(self, method, channel, index, flt):
        """
        XML Struct with double parameters input: Channel Structure and Integer.

        method to build xml structure with:
        method - the function you want to call
        channel - 'analog' 'digital' or 'calc'
        index - number of the channel
        integer - int
        returns:
        data - xml structure
        """
        member = self.getChannelMembers(channel=channel, index=index)
        param1 = self.paramStruct.format(member=member)
        param2 = self.paramSingle.format(type='float', value=float(flt))
        data = self.structMethod.format(func=method, struct=param1+param2)
        return data

    def getMethodData_ChannelAndTypeStrucure(self, method, channel, index, ctype, endian):
        """
        XML Struct with double parameters input: Channel Structure and Type.

        Type is defined by the ctype and endian
        method to build xml structure with:
        method - the function you want to call
        channel - 'analog' 'digital' or 'calc'
        index - number of the channel
        ctype - str 'double', 'float' or 'short'
        endian - str 'little' or 'big'
        returns:
        data - xml structure
        """
        member = self.getChannelMembers(channel=channel, index=index)
        param1 = self.paramStruct.format(member=member)
        typeMember = self.structMemberType.format(type='string', value=ctype)
        endianMember = self.structMemberEndian.format(value=endian)
        param2 = self.paramStruct.format(member=typeMember+endianMember)
        data = self.structMethod.format(func=method, struct=param1+param2)
        return data

    def getMethodData_TemplateGTL(self, data):
        """
        XML Struct with gtl file getMethodData_TemplateGTL.

        data - base 64 encoded AcqKnowledge “gtl” graph template file
        returns:
        data - xml structure
        """
        method = 'loadTemplate'
        param = self.paramEmpty.format(value=data)
        data = self.structMethod.format(func=method, struct=param)
        return data

    # Querying Acquisition Parameters

    def getMPUnitType(self):
        """
        Get the MPUnit.

        returns: int - mpunit number: 0 no unit connected, 160, 150 or 36

        """
        return self.biopacXMLRPC.acq.getMPUnitType()

    def getEnabledChannels(self):
        """
        Get the Channels that are enabled.

        returns: array of arrays, [analogs, digitals, calc] with array
        populated with int for each type of channel

        """
        a = self.getAnalogChannels()
        d = self.getDigitalChannels()
        c = self.getCalcChannels()
        return a, d, c

    def getAnalogChannels(self):
        """
        Get the Analog Channels that are enabled.

        returns: array populated with int for this type of channel

        """
        self.analogChannels = self.biopacXMLRPC.acq.getEnabledChannels('analog')
        return self.analogChannels

    def getDigitalChannels(self):
        """
        Get the Digital Channels that are enabled.

        returns: array populated with int for this type of channel

        """
        self.digitalChannels = self.biopacXMLRPC.acq.getEnabledChannels('digital')
        return self.digitalChannels

    def getCalcChannels(self):
        """
        Get the Calc Channels that are enabled.

        returns: array populated with int for this type of channel

        """
        self.calcChannels = self.biopacXMLRPC.acq.getEnabledChannels('calc')
        return self.calcChannels

    def getChannelScaling(self, channel, index):
        """
        Get the Current Offset and Scale for scpecific channel.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        Returns:
        offset, scale - float

        """
        data = self.getMethodData_ChannelStructure(
            'getChannelScaling',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        self.offset = float(re.findall(r'<name>offset</name>\r\n<value><double>([-+]?[0-9]*\.?[0-9]+)</double>', req.text)[0])
        self.scale = float(re.findall(r'<name>scale</name>\r\n<value><double>([-+]?[0-9]*\.?[0-9]+)</double>', req.text)[0])
        return self.offset, self.scale

    def getSampRate(self):
        """
        Get the samplingRate.

        Returns:
        samplingRate - double

        """
        self.fs = self.biopacXMLRPC.acq.getSamplingRate()
        return self.fs

    def getDownsamplingDivider(self, channel, index):
        """
        Get the Current Downsampling Divider for specific channel.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        Returns:
        DownsamplingDivider - int

        """
        data = self.getMethodData_ChannelStructure(
            'getDownsamplingDivider',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        self.downSampDivider = float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])
        return self.downSampDivider

    # Data Connection Configuration Commands

    def getDataConnectionMethod(self):
        """
        Get the Current Data Connection Method.

        Returns:
        connectioMethod - 'single' or 'multiple'

        """
        self.connectionMethods = self.biopacXMLRPC.acq.getDataConnectionMethod()
        return self.connectionMethods

    def changeDataConnectionMethod(self, method='single'):
        """
        Change the Current Data Connection Method.

        Input:
        method - 'single' or 'multiple'
        returns:
        <change attributes of the class>

        """
        if method == 'single':
            tmp = self.biopacXMLRPC.acq.changeDataConnectionMethod('single')
            if tmp == 0:
                self.singleMethodEnabled = True
            else:
                self.singleMethodEnabled = False
        elif method == 'multiple':
            tmp = self.biopacXMLRPC.acq.changeDataConnectionMethod('multiple')
            if tmp == 0:
                self.multipleMethodEnabled = True
            else:
                self.multipleMethodEnabled = False
        else:
            print('Method not recognized by the system!')

    def getDataConnectionHostname(self):
        """
        Get the Current Data Connection Hostname.

        Returns:
        hostname - string

        """
        self.DataConnectionHostname = self.biopacXMLRPC.acq.getDataConnectionHostname()
        return self.DataConnectionHostname

    def changeDataConnectionHostname(self, hostname=''):
        """
        Change the Current Data Connection Hostname.

        Input:
        hostname - string
        returns:
        True or False

        """
        if len(hostname) == 0:
            print('Changing data connection to the most recent client...')
        tmp = self.biopacXMLRPC.acq.changeDataConnectionHostname(hostname)
        if tmp == 0:
            print('Changed')
            return True
        else:
            print('Failure!')
            return False

    def getTransportType(self):
        """
        Get the Current Transport Type.

        Returns:
        transportType - 'tcp' or 'udp'

        """
        self.TcpOrUDP = self.biopacXMLRPC.acq.getTransportType()
        return self.TcpOrUDP

    def changeTransportType(self, transport):
        """
        Change the Current Data Trasport Type.

        Input:
        transport - string 'tcp' or 'udp'
        returns:
        <change attributes of the class>
        transportType - string 'tcp' or 'udp'

        """
        if transport == 'tcp':
            rsp = self.biopacXMLRPC.acq.changeTransportType('tcp')
            if rsp == 0:
                self.TcpOrUDP = 'tcp'
            else:
                self.TcpOrUDP = 'udp'
        elif transport == 'udp':
            rsp = self.biopacXMLRPC.acq.changeTransportType('udp')
            if rsp == 0:
                self.TcpOrUDP = 'udp'
            else:
                self.TcpOrUDP = 'tcp'
        return self.getTransportType()

    def getUDPSize(self):
        """
        Get the Current UDP datapacket size.

        Returns:
        UDPSize - int

        """
        self.UDPSize = self.biopacXMLRPC.acq.getUDPPacketSize()
        return self.UDPSize

    def setUDPPacketSize(self, size):
        """
        Change the Current UDP datapacket size.

        Input:
        size - int
        returns:
        True if success False otherwise

        """
        tmp = self.biopacXMLRPC.acq.getUDPPacketSize(size)
        if tmp == 0:
            return True
        else:
            return False

    def getUDPBroadcastEnabled(self):
        """
        Check if the Broadcast is enabled.

        Returns:
        True or False

        """
        return self.biopacXMLRPC.acq.getUDPBroadcastEnabled()

    def changeUDPBroadcastEnabled(self, boolean):
        """
        Change the state of the Broadcase.

        Input:
        boolean - True or False
        returns:
        True if broadcast is enabled or False otherwise

        """
        tmp = self.biopacXMLRPC.acq.changeUDPBroadcastEnabled(boolean)
        if tmp == 0:
            if boolean is True:
                print('UDP Broadcast Enabled')
            elif boolean is False:
                print('UDP Broadcast Disabled')
        else:
            print('Failure')
        return self.getUDPBroadcastEnabled()

    def getSingleConnectionModePort(self):
        """
        Check the port number which the server delivers data for single conn.

        returns:
        int - port number

        """
        return self.biopacXMLRPC.acq.getSingleConnectionModePort()

    def changeSingleConnectionModePort(self, port=15020):
        """
        Change the port number which the server delivers data for single conn.

        Input:
        port - int with the port number
        returns:
        True if port was changed or False otherwise

        """
        tmp = self.biopacXMLRPC.acq.changeSingleConnectionModePort(port)
        if tmp == 0:
            print('New Single Connection at Port: ', port)
            rsp = True
        else:
            print('Failed to set new single connection port at port ', port)
            rsp = False
        return rsp

    def getDataDeliveryEnabled(self, channel, index):
        """
        Check if data delivery is enabled for a specific channel.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        Returns:
        True if data delivery is enabled or False otherwise

        """
        data = self.getMethodData_ChannelStructure(
            'getDataDeliveryEnabled',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        tmp = bool(float(re.findall(r'<value><boolean>([-+]?[0-9]*\.?[0-9]+)</boolean>', req.text)[0]))
        return tmp

    def changeDataDeliveryEnabled(self, channel, index, boolean=True):
        """
        Change the data delivery enabled/disabled for a specific channel.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        boolean - True or False to enable/disable
        Returns:
        True if data delivery is enabled or False otherwise

        """
        data = self.getMethodData_ChannelAndBoolStrucure(
            'changeDataDeliveryEnabled',
            channel,
            index,
            boolean
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        if not bool(float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])):
            print('Changed!')
        else:
            print('Failed!')
        return self.getDataDeliveryEnabled(channel, index)

    def getMostRecentSampleValueDeliveryEnabled(self, channel, index):
        """
        Check if the delivery of most recent data sample is enabled.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        Returns:
        True if data delivery is enabled or False otherwise

        """
        data = self.getMethodData_ChannelStructure(
            'getMostRecentSampleValueDeliveryEnabled',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        tmp = float(re.findall(r'<value><boolean>([-+]?[0-9]*\.?[0-9]+)</boolean>', req.text)[0])
        if tmp == 0:
            return True
        else:
            return False

    def changeMostRecentSampleValueDeliveryEnabled(self, channel, index, boolean=True):
        """
        Change if the delivery of most recent data sample is enabled.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        boolean - True or False to enable/disable
        Returns:
        True if data delivery is enabled or False otherwise

        """
        data = self.getMethodData_ChannelAndBoolStrucure(
            'changeMostRecentSampleValueDeliveryEnabled',
            channel,
            index,
            boolean
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        if not bool(float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])):
            print('Changed!')
        else:
            print('Failed!')
        return self.getMostRecentSampleValueDeliveryEnabled(channel, index)

    def getDataConnectionPort(self, channel, index):
        """
        Check the port number which the server delivers data for multiple conn.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        returns:
        int - port number

        """
        data = self.getMethodData_ChannelStructure(
            'getDataConnectionPort',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        self.dataConnectionPort = int(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])
        return self.dataConnectionPort

    def changeDataConnectionPort(self, channel, index, port):
        """
        Change port number which the server delivers data for multiple conn.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        port - int with the port number
        returns:
        True if port was changed or False otherwise

        """
        data = self.getMethodData_ChannelAndIntStrucure(
            'changeMostRecentSampleValueDeliveryEnabled',
            channel,
            index,
            port
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        if not bool(float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])):
            print('Data Connection Port changed to port ', port)
            rsp = True
        else:
            print('Failed!')
            rsp = False
        return rsp

    def getDataType(self, channel, index):
        """
        Check data type is being used for specific channel.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        returns:
        endianType, cstyleType
            endian might be 'little' or 'big'
            cstyle might be 'short', 'double' or 'float'

        """
        data = self.getMethodData_ChannelStructure(
            'getDataType',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        self.endianDataType = str(re.findall(r'<name>endian</name>\r\n<value><string>([-+]?[a-z]*\.?[a-z]+)</string></value>', req.text)[0])
        self.cstyleDataType = str(re.findall(r'<name>type</name>\r\n<value><string>([-+]?[a-z]*\.?[a-z]+)</string></value>', req.text)[0])
        return self.endianDataType, self.cstyleDataType

    def changeDataType(self, channel, index, ctype, endian):
        """
        Change data type used for bin data stream.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        ctype - str with 'double', 'float', 'short'
        endian - str with 'little' or 'big'
        returns:
        True if type was changed or False otherwise

        """
        data = self.getMethodData_ChannelAndTypeStrucure(
            'changeDataType',
            channel,
            index,
            ctype,
            endian
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        if not bool(float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])):
            print('Data Type Changed')
            rsp = True
        else:
            print('Failed!')
            rsp = False
        return rsp

    def setDataConnectionTimeoutSec(self, timeout):
        """
        Change data connection timeout in seconds.

        Input:
        timeout - int with timentout in seconds
        returns:
        True if port was changed or False otherwise

        """
        tmp = self.biopacXMLRPC.acq.setDataConnectionTimeoutSec(int(timeout))
        if tmp == 0:
            print('New Data Connection Timeout: ', int(timeout))
            rsp = True
        else:
            print('Failed to set new timeout period of ', int(timeout))
            rsp = False
        return rsp

    # Reading Data During Acquisition

    def getMostRecentSampleValue(self, channel, index):
        """
        Get the most recent sample value for specific channel.

        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        returns:
        float - most recent value

        """
        data = self.getMethodData_ChannelStructure(
            'getMostRecentSampleValue',
            channel,
            index
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        print(req.text)
        try:
            tmp = float(re.findall(r'<value><double>([-+]?[0-9]*\.?[0-9]+)</double></value>', req.text)[0])
            return tmp
        except ValueError:
            print('Error... Check if getMostRecentSampleValueDeliveryEnabled is enabled!')

    def getMostRecentSampleValueArray(self):
        """
        Get the most recent sample value array (all channels).

        returns:
        array - structure with channel info and values

        """
        tmp = self.biopacXMLRPC.acq.getMostRecentSampleValueArray()
        return tmp

    # Other Control Connection Commands

    def loadTemplate(self, gtlData):
        """
        Load a template gtl file into AcqKnoweldge.

        Input:
        data - base 64 encoded AcqKnowledge “gtl” graph template file.
        returns:
        True if sucess of False otherwise

        """
        data = self.getMethodData_TemplateGTL(gtlData)
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        if not bool(float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])):
            print('Data Type Changed')
            rsp = True
        else:
            print('Failed!')
            rsp = False
        return rsp

    def getAcquisitionInProgress(self):
        """
        Check if an acquisition is in progress.

        returns:
        True or False

        """
        return self.biopacXMLRPC.acq.getAcquisitionInProgress()

    def toggleAcquisition(self):
        """
        Toggle acquisition.

        If data acquisition is in progress it will stop.
        If data acquisition is stopped it will start.
        returns:
        True on succsess or False othewise

        """
        tmp = self.biopacXMLRPC.acq.toggleAcquisition()
        if tmp == 0:
            print('Toggled - started or stopped')
            rsp = True
        else:
            print('Failed to toggle acquisition')
            rsp = False
        return rsp

    def setOutputChannel(self, channel, index, flt):
        """
        Change voltage of specified output channel.

        Not available for all channels:
        analog outputs - the value should be in the range (-10, 10)
        digital outputs - a value of 0 will turn the specified line off,
            a nonzero value will turn it on
        Input:
        channel - 'analog' 'digital' or 'calc'
        index - int
        port - float - voltafe
        returns:
        True if port was changed or False otherwise

        """
        data = self.getMethodData_ChannelAndFloatStrucure(
            'setOutputChannel',
            channel,
            index,
            flt
            )
        req = requests.post(
            self.proxyNameEndPoint,
            data=data,
            headers=self.requestsHeader
            )
        self.reqText = req.text
        if not bool(float(re.findall(r'<i4>([-+]?[0-9]*\.?[0-9]+)</i4>', req.text)[0])):
            print('Voltage changed')
            rsp = True
        else:
            print('Failed!')
            rsp = False
        return rsp
